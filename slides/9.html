<!DOCTYPE html>
<html lang="en">

<head>
  <title>Learning-Enabled Verification of Distributed Systems with End-to-End Proofs</title>
  <script src="https://unpkg.com/konva@8/konva.min.js"></script>
  <link href='https://fonts.googleapis.com/css?family=Open Sans' rel='stylesheet'>
  <link href="../reset.css" rel="stylesheet" type="text/css" />
  <link href="../style.css" rel="stylesheet" type="text/css" />
</head>

<body>
  <div class="title-box">
    <div class="title">Proposal Details: <span id="learning">Inductive</span> & <span id="proofs">Deductive</span> Reasoning</div>
  </div>
  <div class="full-box" style="margin-top: -100px;"><div id="canvas"></div></div>
  <div id="goals" style="height: 100px; text-align: center;"></div>
  <div class="foot-box">
    <div class="slide-number"></div>
  </div>
</body>

<script type="module">
  import { annotate } from 'https://unpkg.com/rough-notation?module';
  import { step, primary_color, secondary_color, tertiary_color, quaternary_color, draw_rectangle_konva, draw_arrow_konva } from "../utils.js";

  const width = 1920;
  const height = 1080 - 350;

  var stage = new Konva.Stage({
    container: 'canvas',
    width: width,
    height: height,
  });
  var layer = new Konva.Layer();
  stage.add(layer);

  const vert_gap = 60;
  const horiz_gap = 150;

  const doc_width = 150;
  const doc_height = 200;
  const doc_corners = [0, 20, 0, 0];

  const big_process_width = 1100;
  const big_process_height = 500;
  const process_corners = [0, 0, 0, 0];

  const left_most_x = (width - (big_process_width + doc_width + doc_width + horiz_gap + horiz_gap)) / 2;
  const upmost_y = (height - (doc_height + doc_height + vert_gap)) / 2;

  var system = draw_rectangle_konva(layer, left_most_x, upmost_y, doc_width, doc_height, doc_corners, "transparent", primary_color, primary_color, "User System");
  var invariant = draw_rectangle_konva(layer, system[0].x(), system[0].y() + system[0].height() + vert_gap, doc_width, doc_height, doc_corners, "transparent", primary_color, primary_color, "User Invariant");

  var tool = draw_rectangle_konva(layer, system[0].x() + system[0].width() + horiz_gap, system[0].y() + ((system[0].height() + invariant[0].height() + vert_gap) / 2) - (big_process_height / 2), big_process_width, big_process_height, process_corners, "transparent", primary_color, primary_color, "");
  
  var proof = draw_rectangle_konva(layer, tool[0].x() + tool[0].width() + horiz_gap, system[0].y(), doc_width, doc_height, doc_corners, "transparent", primary_color, primary_color, "Proof");
  var help = draw_rectangle_konva(layer, proof[0].x(), proof[0].y() + proof[0].height() + vert_gap, doc_width, doc_height, doc_corners, "transparent", primary_color, primary_color, "Suggested Invariant");

  var ringSystemImage = new Image();
  var ringSystemPng = new Konva.Image({
      x: system[0].x() + 20,
      y: system[0].y() + 70,
      image: ringSystemImage,
      width: system[0].width()  - 40,
      height: system[0].height() - 80,
    });
  ringSystemImage.onload = function () {
    layer.add(ringSystemPng);
  };
  ringSystemImage.src = '../images/ring.png';
  system = system.concat(ringSystemPng);

  var ringInvImage = new Image();
  var ringInvPng = new Konva.Image({
      x: invariant[0].x() + 20,
      y: invariant[0].y() + 70,
      image: ringInvImage,
      width: invariant[0].width()  - 40,
      height: invariant[0].height() - 80,
    });
  ringInvImage.onload = function () {
    layer.add(ringInvPng);
  };
  ringInvImage.src = '../images/ring_inv.png';
  invariant = invariant.concat(ringInvPng);

  // add text to center of help
  var helpText = new Konva.Text({
    x: help[0].x(),
    y: help[0].y() + 20,
    text: 'P(s)',
    fontSize: 30,
    fontFamily: 'Open Sans',
    fill: secondary_color,
    width: help[0].width(),
    height: help[0].height(),
    align: 'center',
    verticalAlign: 'middle',
  });
  layer.add(helpText);
  help = help.concat(helpText);

  system = system.concat(draw_arrow_konva(layer, system[0], tool[0], primary_color, primary_color, ""));
  invariant = invariant.concat(draw_arrow_konva(layer, invariant[0], tool[0], primary_color, primary_color, ""));

  const little_gap = 3.5 * horiz_gap / 7;
  const little_process_width = (big_process_width - (6 * little_gap)) / 5;
  const little_process_height = big_process_height - vert_gap;
  var rewriter = draw_rectangle_konva(layer, tool[0].x() + little_gap, tool[0].y() + vert_gap/3, little_process_width, little_process_height / 2, process_corners, "transparent", quaternary_color, primary_color, "Learned Rewriter");
  
  //draw dashed box around rewriter
  var rewriterBox = new Konva.Rect({
    x: rewriter[0].x(),
    y: rewriter[0].y(),
    width: rewriter[0].width(),
    height: rewriter[0].height(),
    stroke: tertiary_color,
    strokeWidth: 5,
    dash: [10, 10],
  });
  layer.add(rewriterBox);
  rewriter = rewriter.concat(rewriterBox);
  
  var encoder = draw_rectangle_konva(layer, rewriter[0].x() + rewriter[0].width() + little_gap, rewriter[0].y(), little_process_width, little_process_height / 2, process_corners, "transparent", tertiary_color, primary_color, "Encoder");
  var solver_interface = draw_rectangle_konva(layer, encoder[0].x() + encoder[0].width() + little_gap, tool[0].y() + tool[0].height() / 2 - little_process_height/4, little_process_width, little_process_height / 2, process_corners, "transparent", quaternary_color, primary_color, "Learned Solver Interface");
  var solver = draw_rectangle_konva(layer, solver_interface[0].x() + solver_interface[0].width() + little_gap, solver_interface[0].y(), little_process_width, little_process_height / 2, process_corners, "transparent", tertiary_color, primary_color, "Solver");
  var decoder = draw_rectangle_konva(layer, solver[0].x() + solver[0].width() + little_gap, encoder[0].y(), little_process_width, little_process_height / 2, process_corners, "transparent", tertiary_color, primary_color, "Decoder");
  
  var instrumenter = draw_rectangle_konva(layer, rewriter[0].x(), rewriter[0].y() + rewriter[0].height() + vert_gap/3, little_process_width, little_process_height / 2, process_corners, "transparent", tertiary_color, primary_color, "Message Chain Embeder");
  var fuzzer = draw_rectangle_konva(layer, encoder[0].x(), rewriter[0].y() + rewriter[0].height() + vert_gap/3, little_process_width, little_process_height / 2, process_corners, "transparent", quaternary_color, primary_color, "Sampler");
  var spec_miner = draw_rectangle_konva(layer, decoder[0].x(), encoder[0].y() + encoder[0].height() + vert_gap/3, little_process_width, little_process_height / 2, process_corners, "transparent", quaternary_color, primary_color, "Spec. Miner");

  // draw an arrow from the left of tool to the left of instrumenter
  var tool_to_instrumenter = new Konva.Arrow({
    points: [tool[0].x(), instrumenter[0].y() + 3 * instrumenter[0].height() / 4, instrumenter[0].x() - 10, instrumenter[0].y() + 3 * instrumenter[0].height() / 4],
    pointerLength: 10,
    pointerWidth: 10,
    fill: primary_color,
    stroke: primary_color,
    strokeWidth: 5,
  });
  layer.add(tool_to_instrumenter);
  instrumenter = instrumenter.concat(tool_to_instrumenter);

  decoder = decoder.concat(draw_arrow_konva(layer, decoder[0], proof[0], primary_color, primary_color, "      success"));
  decoder = decoder.concat(proof);
  spec_miner = spec_miner.concat(draw_arrow_konva(layer, spec_miner[0], help[0], primary_color, primary_color, "    failure"));
  spec_miner = spec_miner.concat(help);

  //draw dashed box around spec miner
  var specMinerBox = new Konva.Rect({
    x: spec_miner[0].x(),
    y: spec_miner[0].y(),
    width: spec_miner[0].width(),
    height: spec_miner[0].height(),
    stroke: tertiary_color,
    strokeWidth: 5,
    dash: [10, 10],
  });
  layer.add(specMinerBox);
  spec_miner = spec_miner.concat(specMinerBox);

  var rewriter_to_encoder = draw_arrow_konva(layer, rewriter[0], encoder[0], quaternary_color, primary_color, "");
  rewriter = rewriter.concat(rewriter_to_encoder);
  // add dashes to rewriter to encoder arrow
  var rewriter_to_encoder_dash = new Konva.Line({
    points: [rewriter_to_encoder[0].points()[0], rewriter_to_encoder[0].points()[1], rewriter_to_encoder[0].points()[2] - 10, rewriter_to_encoder[0].points()[3]],
    stroke: tertiary_color,
    strokeWidth: 5,
    dash: [10, 10],
  });
  layer.add(rewriter_to_encoder_dash);
  rewriter = rewriter.concat(rewriter_to_encoder_dash);
  
  solver_interface = solver_interface.concat(draw_arrow_konva(layer, solver_interface[0], solver[0], quaternary_color, primary_color, ""));

  var encoder_to_solver_interface = new Konva.Arrow({
    points: [encoder[0].x() + encoder[0].width(), encoder[0].y() + 3 * encoder[0].height() / 4, solver_interface[0].x() - 10, encoder[0].y() + 3 * encoder[0].height() / 4],
    pointerLength: 10,
    pointerWidth: 10,
    fill: tertiary_color,
    stroke: tertiary_color,
    strokeWidth: 5,
  });
  layer.add(encoder_to_solver_interface);;
  encoder = encoder.concat(encoder_to_solver_interface);

  var solver_to_decoder = new Konva.Arrow({
    points: [solver[0].x() + solver[0].width(), encoder[0].y() + 3 * encoder[0].height() / 4, decoder[0].x() - 10, encoder[0].y() + 3 * encoder[0].height() / 4],
    pointerLength: 10,
    pointerWidth: 10,
    fill: tertiary_color,
    stroke: tertiary_color,
    strokeWidth: 5,
  });
  layer.add(solver_to_decoder);
  solver = solver.concat(solver_to_decoder);

  var encoder_to_decoder = new Konva.Arrow({
    points: [encoder[0].x() + encoder[0].width(), encoder[0].y() + encoder[0].height() / 4, decoder[0].x() - 10, encoder[0].y() + encoder[0].height() / 4],
    pointerLength: 10,
    pointerWidth: 10,
    fill: tertiary_color,
    stroke: tertiary_color,
    strokeWidth: 5,
  });
  layer.add(encoder_to_decoder);
  encoder = encoder.concat(encoder_to_decoder);

  var encoder_to_decoder_text = new Konva.Text({
    x: encoder_to_decoder.points()[0],
    y: encoder_to_decoder.points()[1] - 29,
    text: "Encoding Proof",
    fontSize: 24,
    fontFamily: 'Open Sans',
    fill: primary_color,
    width: encoder_to_decoder.points()[2] - encoder_to_decoder.points()[0],
    align: 'center',
  });
  layer.add(encoder_to_decoder_text);
  encoder = encoder.concat(encoder_to_decoder_text);

  var instrumenter_to_fuzzer = new Konva.Arrow({
    points: [instrumenter[0].x() + instrumenter[0].width(), instrumenter[0].y() + instrumenter[0].height()/2, fuzzer[0].x() - 10, instrumenter[0].y() + instrumenter[0].height()/2],
    pointerLength: 10,
    pointerWidth: 10,
    fill: tertiary_color,
    stroke: tertiary_color,
    strokeWidth: 5,
  });
  layer.add(instrumenter_to_fuzzer);
  fuzzer = fuzzer.concat(instrumenter_to_fuzzer);

  var fuzzer_to_spec_miner = new Konva.Arrow({
    points: [fuzzer[0].x() + fuzzer[0].width(), fuzzer[0].y() + 3 * fuzzer[0].height() / 4, spec_miner[0].x() - 10, fuzzer[0].y() + 3 * fuzzer[0].height() / 4],
    pointerLength: 10,
    pointerWidth: 10,
    fill: quaternary_color,
    stroke: quaternary_color,
    strokeWidth: 5,
  });
  layer.add(fuzzer_to_spec_miner);
  fuzzer = fuzzer.concat(fuzzer_to_spec_miner);

  var fuzzer_to_spec_miner_text = new Konva.Text({
    x: fuzzer_to_spec_miner.points()[0],
    y: fuzzer_to_spec_miner.points()[1] + 10,
    text: "Traces and Invariants",
    fontSize: 24,
    fontFamily: 'Open Sans',
    fill: primary_color,
    width: fuzzer_to_spec_miner.points()[2] - fuzzer_to_spec_miner.points()[0],
    align: 'center',
  });
  layer.add(fuzzer_to_spec_miner_text);
  fuzzer = fuzzer.concat(fuzzer_to_spec_miner_text);

  // draw elbow connector between right of decoder and right of spec miner
  var decoder_to_spec_miner = new Konva.Arrow({
    points: [decoder[0].x() + decoder[0].width(), decoder[0].y() + decoder[0].height()/2 + 30, decoder[0].x() + decoder[0].width() + 45, decoder[0].y() + decoder[0].height()/2 + 30, decoder[0].x() + decoder[0].width() + 45, spec_miner[0].y() + spec_miner[0].height()/2 - 30, spec_miner[0].x() + spec_miner[0].width() + 10, spec_miner[0].y() + spec_miner[0].height()/2 - 30],
    pointerLength: 10,
    pointerWidth: 10,
    fill: tertiary_color,
    stroke: tertiary_color,
    strokeWidth: 5,
  });
  layer.add(decoder_to_spec_miner);
  spec_miner = spec_miner.concat(decoder_to_spec_miner);

  // draw elbow connector between left of instrumenter and left of rewriter
  var instrumenter_to_rewriter = new Konva.Arrow({
    points: [instrumenter[0].x(), instrumenter[0].y() + instrumenter[0].height()/2, instrumenter[0].x() - 45, instrumenter[0].y() + instrumenter[0].height()/2, instrumenter[0].x() - 45, rewriter[0].y() + rewriter[0].height()/2, rewriter[0].x() - 10, rewriter[0].y() + rewriter[0].height()/2],
    pointerLength: 10,
    pointerWidth: 10,
    fill: tertiary_color,
    stroke: tertiary_color,
    strokeWidth: 5,
  });
  layer.add(instrumenter_to_rewriter);
  instrumenter = instrumenter.concat(instrumenter_to_rewriter);

  var learning = document.querySelector('#learning');
  learning = annotate(learning, { type: 'box', color: quaternary_color, strokeWidth: 10 });

  var proofs = document.querySelector('#proofs');
  proofs = annotate(proofs, { type: 'box', color: tertiary_color, strokeWidth: 10 });


  // add text to middle of instrumenter saying "1"
  var instrumenter_text = new Konva.Text({
    x: instrumenter[0].x() + instrumenter[0].width()/2 - 20,
    y: instrumenter[0].y() + instrumenter[0].height()/2 - 20,
    text: "1",
    fontSize: 80,
    fontFamily: 'Open Sans',
    fill: "red",
  });
  layer.add(instrumenter_text);
  instrumenter_text = [instrumenter_text];

  // add text to middle of spec_miner saying "2"
  var spec_miner_text = new Konva.Text({
    x: spec_miner[0].x() + spec_miner[0].width()/2 - 20,
    y: spec_miner[0].y() + spec_miner[0].height()/2 - 20,
    text: "2",
    fontSize: 80,
    fontFamily: 'Open Sans',
    fill: "red",
  });
  layer.add(spec_miner_text);
  spec_miner_text = [spec_miner_text];

  // add text to middle of solver_interface saying "3"
  var solver_interface_text = new Konva.Text({
    x: solver_interface[0].x() + solver_interface[0].width()/2 - 20,
    y: solver_interface[0].y() + solver_interface[0].height()/2 - 20,
    text: "3",
    fontSize: 80,
    fontFamily: 'Open Sans',
    fill: "red",
  });
  layer.add(solver_interface_text);
  solver_interface_text = [solver_interface_text];

  // add text to middle of decoder saying "4"
  var proof_text = new Konva.Text({
    x: proof[0].x() + proof[0].width()/2 - 20,
    y: proof[0].y() + proof[0].height()/2 - 20,
    text: "4",
    fontSize: 80,
    fontFamily: 'Open Sans',
    fill: "red",
  });
  layer.add(proof_text);
  proof_text = [proof_text];

  // select goals element 
  var goals = document.querySelector('#goals');

  const elements = [tool, system, invariant, learning, proofs, instrumenter, rewriter, encoder, solver_interface, solver, decoder, fuzzer, spec_miner, instrumenter_text, spec_miner_text, solver_interface_text, proof_text];

  function clean() {
    for (const x of elements) {
      if (Array.isArray(x)) {
        for (const y of x) {
          y.hide();
        }
      } else {
        x.hide();
      }
    }
    learning.hide();
    proofs.hide();
  }

  clean();

  var to_appear = [[]];
  for (const x of elements) {
    function f() {
      if (Array.isArray(x)) {
        for (const y of x) {
          y.show();
        }
      } else {
        x.show();
      }
    }
    function g() {
      if (x == instrumenter_text) {
        goals.innerHTML = "(1) Reasoning about \"stray\" messages. &nbsp;"
      } else if (x == spec_miner_text) {
        goals.innerHTML = goals.innerHTML + "(2) Coming up with true invariants.<br>"
      } else if (x == solver_interface_text) {
        goals.innerHTML = goals.innerHTML + "(3) Getting solvers to terminate. &nbsp;"
      } else if (x == proof_text) {
        goals.innerHTML = goals.innerHTML + "(4) Checking and sharing verification results."
      }
    }
    to_appear.push([f, g]);
  }

  var to_disappear = [];
  for (const x of to_appear) { 
    to_disappear.push([]);
  }

  var state = 0;
  const body = document.querySelector('body');
  body.onkeydown = function (e) { state = step(e, state, to_disappear, to_appear) };
</script>

<script type='module' src="../next.js"></script>

</html>