<!DOCTYPE html>
<html lang="en">

<head>
  <title>Learning-Enabled Verification of Distributed Systems with End-to-End Proofs</title>
  <script src="https://unpkg.com/konva@8/konva.min.js"></script>
  <link href='https://fonts.googleapis.com/css?family=Open Sans' rel='stylesheet'>
  <link href="../reset.css" rel="stylesheet" type="text/css" />
  <link href="../style.css" rel="stylesheet" type="text/css" />
</head>

<body>
  <div class="title-box">
    <div class="title">Proposal Overview: <span id="learning">Inductive</span> & <span id="proofs">Deductive</span> Reasoning Architecture</div>
  </div>
  <div class="full-box"><div id="canvas"></div></div>
  <div class="foot-box">
    <div class="slide-number"></div>
  </div>
</body>

<script type="module">
  import { annotate } from 'https://unpkg.com/rough-notation?module';
  import { step, primary_color, secondary_color, tertiary_color, quaternary_color, draw_rectangle_konva, draw_arrow_konva } from "../utils.js";

  const width = 1920;
  const height = 1080 - 350;

  var stage = new Konva.Stage({
    container: 'canvas',
    width: width,
    height: height,
  });
  var layer = new Konva.Layer();
  stage.add(layer);

  const vert_gap = 50;
  const horiz_gap = 150;

  const doc_width = 150;
  const doc_height = 200;
  const doc_corners = [0, 20, 0, 0];

  const big_process_width = 1000;
  const big_process_height = 500;
  const process_corners = [0, 0, 0, 0];

  const left_most_x = (width - (big_process_width + doc_width + doc_width + horiz_gap + horiz_gap)) / 2;
  const upmost_y = (height - (doc_height + doc_height + vert_gap)) / 2;

  var system = draw_rectangle_konva(layer, left_most_x, upmost_y, doc_width, doc_height, doc_corners, "transparent", primary_color, primary_color, "User System");
  var invariant = draw_rectangle_konva(layer, system[0].x(), system[0].y() + system[0].height() + vert_gap, doc_width, doc_height, doc_corners, "transparent", primary_color, primary_color, "User Invariant");

  var tool = draw_rectangle_konva(layer, system[0].x() + system[0].width() + horiz_gap, system[0].y() + ((system[0].height() + invariant[0].height() + vert_gap) / 2) - (big_process_height / 2), big_process_width, big_process_height, process_corners, "transparent", primary_color, primary_color, "");
  
  var proof = draw_rectangle_konva(layer, tool[0].x() + tool[0].width() + horiz_gap, system[0].y(), doc_width, doc_height, doc_corners, "transparent", primary_color, primary_color, "Proof");
  var help = draw_rectangle_konva(layer, proof[0].x(), proof[0].y() + proof[0].height() + vert_gap, doc_width, doc_height, doc_corners, "transparent", primary_color, primary_color, "Suggested Invariant");

  var ringSystemImage = new Image();
  var ringSystemPng = new Konva.Image({
      x: system[0].x() + 20,
      y: system[0].y() + 50,
      image: ringSystemImage,
      width: system[0].width()  - 40,
      height: system[0].height() - 80,
    });
  ringSystemImage.onload = function () {
    layer.add(ringSystemPng);
  };
  ringSystemImage.src = '../icons/ring.png';
  system = system.concat(ringSystemPng);

  var ringInvImage = new Image();
  var ringInvPng = new Konva.Image({
      x: invariant[0].x() + 20,
      y: invariant[0].y() + 50,
      image: ringInvImage,
      width: invariant[0].width()  - 40,
      height: invariant[0].height() - 80,
    });
  ringInvImage.onload = function () {
    layer.add(ringInvPng);
  };
  ringInvImage.src = '../icons/ring_inv.png';
  invariant = invariant.concat(ringInvPng);

  var proofImage = new Image();
  var proofPng = new Konva.Image({
      x: proof[0].x() + 30,
      y: proof[0].y() + 40,
      image: proofImage,
      width: proof[0].width() - 60,
      height: proof[0].height() - 50,
    });
  proofImage.onload = function () {
    layer.add(proofPng);
  };
  proofImage.src = '../icons/proof.png';
  proof = proof.concat(proofPng);

  // add text to center of help
  var helpText = new Konva.Text({
    x: help[0].x(),
    y: help[0].y() + 20,
    text: 'P(s)',
    fontSize: 20,
    fontFamily: 'Open Sans',
    fill: secondary_color,
    width: help[0].width(),
    height: help[0].height(),
    align: 'center',
    verticalAlign: 'middle',
  });
  layer.add(helpText);
  help = help.concat(helpText);

  system = system.concat(draw_arrow_konva(layer, system[0], tool[0], primary_color, primary_color, ""));
  invariant = invariant.concat(draw_arrow_konva(layer, invariant[0], tool[0], primary_color, primary_color, ""));
  proof = proof.concat(draw_arrow_konva(layer, tool[0], proof[0], primary_color, primary_color, "success"));
  help = help.concat(draw_arrow_konva(layer, tool[0], help[0], primary_color, primary_color, "failure"));


  const little_gap = 3.5 * horiz_gap / 7;
  const little_process_width = (big_process_width - (6 * little_gap)) / 5;
  const little_process_height = big_process_height - vert_gap;
  var rewriter = draw_rectangle_konva(layer, tool[0].x() + little_gap, tool[0].y() + vert_gap/3, little_process_width, little_process_height / 1.5, process_corners, "transparent", quaternary_color, primary_color, "Learned Rewriter",);
  
  //draw dashed box around rewriter
  var rewriterBox = new Konva.Rect({
    x: rewriter[0].x(),
    y: rewriter[0].y(),
    width: rewriter[0].width(),
    height: rewriter[0].height(),
    stroke: tertiary_color,
    strokeWidth: 5,
    dash: [10, 10],
  });
  layer.add(rewriterBox);
  rewriter = rewriter.concat(rewriterBox);
  
  var encoder = draw_rectangle_konva(layer, rewriter[0].x() + rewriter[0].width() + little_gap, rewriter[0].y(), little_process_width, little_process_height / 1.5, process_corners, "transparent", tertiary_color, primary_color, "Encoder",);
  var solver_interface = draw_rectangle_konva(layer, encoder[0].x() + encoder[0].width() + little_gap, encoder[0].y(), little_process_width, little_process_height / 2, process_corners, "transparent", quaternary_color, primary_color, "Learned Solver Interface",);
  var solver = draw_rectangle_konva(layer, solver_interface[0].x() + solver_interface[0].width() + little_gap, solver_interface[0].y(), little_process_width, little_process_height / 2, process_corners, "transparent", tertiary_color, primary_color, "Solver",);
  var decoder = draw_rectangle_konva(layer, solver[0].x() + solver[0].width() + little_gap, solver[0].y(), little_process_width, little_process_height / 1.5, process_corners, "transparent", tertiary_color, primary_color, "Decoder",);
  
  var fuzzer = draw_rectangle_konva(layer, rewriter[0].x(), rewriter[0].y() + rewriter[0].height() + vert_gap/3, little_process_width, little_process_height / 3, process_corners, "transparent", quaternary_color, primary_color, "Sampler",);
  var spec_miner = draw_rectangle_konva(layer, solver_interface[0].x(), encoder[0].y() + encoder[0].height() + vert_gap/3, little_process_width * 3 + little_gap * 2, little_process_height / 3, process_corners, "transparent", quaternary_color, primary_color, "Specification Miner",);

  //draw dashed box around spec miner
  var specMinerBox = new Konva.Rect({
    x: spec_miner[0].x(),
    y: spec_miner[0].y(),
    width: spec_miner[0].width(),
    height: spec_miner[0].height(),
    stroke: tertiary_color,
    strokeWidth: 5,
    dash: [10, 10],
  });
  layer.add(specMinerBox);
  spec_miner = spec_miner.concat(specMinerBox);

  rewriter = rewriter.concat(draw_arrow_konva(layer, rewriter[0], encoder[0], quaternary_color, primary_color, ""));
  solver_interface = solver_interface.concat(draw_arrow_konva(layer, solver_interface[0], solver[0], quaternary_color, primary_color, ""));

  var encoder_to_solver_interface = new Konva.Arrow({
    points: [encoder[0].x() + encoder[0].width(), solver_interface[0].y() + solver_interface[0].height()/2, solver_interface[0].x() - 10, solver_interface[0].y() + solver_interface[0].height()/2],
    pointerLength: 10,
    pointerWidth: 10,
    fill: tertiary_color,
    stroke: tertiary_color,
    strokeWidth: 5,
  });
  layer.add(encoder_to_solver_interface);;
  encoder = encoder.concat(encoder_to_solver_interface);

  var solver_to_decoder = new Konva.Arrow({
    points: [solver[0].x() + solver[0].width(), solver[0].y() + solver[0].height()/2, decoder[0].x() - 10, solver[0].y() + solver[0].height()/2],
    pointerLength: 10,
    pointerWidth: 10,
    fill: tertiary_color,
    stroke: tertiary_color,
    strokeWidth: 5,
  });
  layer.add(solver_to_decoder);
  solver = solver.concat(solver_to_decoder);

  var encoder_to_decoder = new Konva.Arrow({
    points: [encoder[0].x() + encoder[0].width(), decoder[0].y() + little_process_height / 1.75, decoder[0].x() - 10, decoder[0].y() + little_process_height / 1.75],
    pointerLength: 10,
    pointerWidth: 10,
    fill: tertiary_color,
    stroke: tertiary_color,
    strokeWidth: 5,
  });
  layer.add(encoder_to_decoder);
  encoder = encoder.concat(encoder_to_decoder);

  var encoder_to_decoder_text = new Konva.Text({
    x: encoder_to_decoder.points()[0],
    y: encoder_to_decoder.points()[1] + 10,
    text: "Encoding Proof",
    fontSize: 18,
    fontFamily: 'Open Sans',
    fill: primary_color,
    width: encoder_to_decoder.points()[2] - encoder_to_decoder.points()[0],
    align: 'center',
  });
  layer.add(encoder_to_decoder_text);
  encoder = encoder.concat(encoder_to_decoder_text);

  var fuzzer_to_spec_miner = new Konva.Arrow({
    points: [fuzzer[0].x() + fuzzer[0].width(), fuzzer[0].y() + fuzzer[0].height()/2, spec_miner[0].x() - 10, fuzzer[0].y() + fuzzer[0].height()/2],
    pointerLength: 10,
    pointerWidth: 10,
    fill: quaternary_color,
    stroke: quaternary_color,
    strokeWidth: 5,
  });
  layer.add(fuzzer_to_spec_miner);
  fuzzer = fuzzer.concat(fuzzer_to_spec_miner);

  var fuzzer_to_spec_miner_text = new Konva.Text({
    x: fuzzer_to_spec_miner.points()[0],
    y: fuzzer_to_spec_miner.points()[1] + 10,
    text: "Traces and Invariants",
    fontSize: 18,
    fontFamily: 'Open Sans',
    fill: primary_color,
    width: fuzzer_to_spec_miner.points()[2] - fuzzer_to_spec_miner.points()[0],
    align: 'center',
  });
  layer.add(fuzzer_to_spec_miner_text);
  fuzzer = fuzzer.concat(fuzzer_to_spec_miner_text);

  var learning = document.querySelector('#learning');
  learning = annotate(learning, { type: 'box', color: quaternary_color, strokeWidth: 10 });

  var proofs = document.querySelector('#proofs');
  proofs = annotate(proofs, { type: 'box', color: tertiary_color, strokeWidth: 10 });

  function clean() {
    for (const x of [tool, system, invariant, proof, help, rewriter, encoder, solver_interface, solver, decoder, fuzzer, spec_miner]) {
      if (Array.isArray(x)) {
        for (const y of x) {
          y.hide();
        }
      } else {
        x.hide();
      }
    }
    learning.hide();
    proofs.hide();
  }

  clean();

  var to_appear = [[]];
  for (const x of [tool, system, invariant, proof, help, learning, proofs, rewriter, encoder, solver_interface, solver, decoder, fuzzer, spec_miner]) {
    function f() {
      if (Array.isArray(x)) {
        for (const y of x) {
          y.show();
        }
      } else {
        x.show();
      }
    }
    to_appear.push([f]);
  }

  var to_disappear = [];
  for (const x of to_appear) { 
    to_disappear.push([]);
  }

  var state = 0;
  const body = document.querySelector('body');
  body.onkeydown = function (e) { state = step(e, state, to_disappear, to_appear) };
</script>

<script type='module' src="../next.js"></script>

</html>